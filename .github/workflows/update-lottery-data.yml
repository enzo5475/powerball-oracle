const fs = require('fs');

/**
 * Fetches latest Powerball data from NY.gov official API
 * API URL: https://data.ny.gov/api/views/d6yy-54nr/rows.json
 * Data is sorted from newest to oldest (today back to 2010)
 */

async function fetchNYLotteryData() {
    try {
        console.log('üé∞ Fetching Powerball data from NY.gov API...');
        
        const response = await fetch('https://data.ny.gov/api/views/d6yy-54nr/rows.json');
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const apiData = await response.json();
        console.log(`üìä Received ${apiData.data.length} total records from NY.gov`);
        
        // Parse the data structure
        // apiData.meta.view.columns contains column definitions
        // apiData.data contains the actual data rows
        
        // Find column indices (NY.gov API structure)
        const columns = apiData.meta.view.columns;
        const columnMap = {};
        
        columns.forEach((col, index) => {
            columnMap[col.name] = index;
        });
        
        console.log('üìã Available columns:', Object.keys(columnMap));
        console.log(`üìä Total records in data array: ${apiData.data.length}`);
        console.log('üîç Checking data array structure...');
        
        // Check both ends of the data array to understand the order
        console.log('First row (index 0):', {
            date: apiData.data[0][columnMap['Draw Date']] || apiData.data[0][1],
            numbers: apiData.data[0][columnMap['Winning Numbers']] || apiData.data[0][2]
        });
        
        const lastIndex = apiData.data.length - 1;
        console.log(`Last row (index ${lastIndex}):`, {
            date: apiData.data[lastIndex][columnMap['Draw Date']] || apiData.data[lastIndex][1],
            numbers: apiData.data[lastIndex][columnMap['Winning Numbers']] || apiData.data[lastIndex][2]
        });
        
        // Get today's date for comparison
        const today = new Date();
        console.log(`üìÖ Today's date: ${today.toISOString().split('T')[0]}`);
        
        // Process ALL data and find the one closest to today
        const processedResults = [];
        let closestToToday = null;
        let smallestDateDiff = Infinity;
        
        apiData.data.forEach((row, index) => {
            try {
                const drawDate = row[columnMap['Draw Date']] || row[1];
                const winningNumbers = row[columnMap['Winning Numbers']] || row[2];
                const multiplier = row[columnMap['Multiplier']] || row[3];
                
                if (!drawDate || !winningNumbers) {
                    return; // Skip invalid rows
                }
                
                // Parse date - handle format: 2025-05-31T00:00:00
                const date = new Date(drawDate);
                const formattedDate = date.toISOString().split('T')[0]; // YYYY-MM-DD
                
                // Calculate days difference from today
                const daysDiff = Math.abs(today - date) / (1000 * 60 * 60 * 24);
                
                // Parse the winning numbers
                const numbersStr = winningNumbers.toString().trim();
                const allNumbers = numbersStr.match(/\d+/g);
                
                if (!allNumbers || allNumbers.length < 6) {
                    return; // Skip invalid number formats
                }
                
                // Convert to integers
                const numbers = allNumbers.map(n => parseInt(n));
                
                // First 5 are white balls, last is red powerball
                const whiteBalls = numbers.slice(0, 5).sort((a, b) => a - b);
                const powerball = numbers[5];
                
                // Validate number ranges
                const validWhite = whiteBalls.every(n => n >= 1 && n <= 69);
                const validRed = powerball >= 1 && powerball <= 26;
                
                if (!validWhite || !validRed) {
                    return; // Skip invalid ranges
                }
                
                const result = {
                    date: formattedDate,
                    dateObj: date,
                    white: whiteBalls,
                    red: powerball,
                    jackpot: "0",
                    multiplier: multiplier || "1",
                    index: index,
                    daysDiff: daysDiff,
                    raw_data: row
                };
                
                processedResults.push(result);
                
                // Track the closest date to today
                if (daysDiff < smallestDateDiff) {
                    smallestDateDiff = daysDiff;
                    closestToToday = result;
                }
                
            } catch (error) {
                return; // Skip problematic rows
            }
        });
        
        if (processedResults.length === 0) {
            throw new Error('No valid lottery results found in API response');
        }
        
        // Sort by date - NEWEST FIRST
        processedResults.sort((a, b) => b.dateObj - a.dateObj);
        
        // Remove the helper properties
        processedResults.forEach(result => {
            delete result.dateObj;
            delete result.daysDiff;
        });
        
        console.log(`‚úÖ Successfully processed ${processedResults.length} drawings`);
        console.log(`üìÖ Date range: ${processedResults[processedResults.length-1].date} to ${processedResults[0].date}`);
        
        // Show the newest drawing (should be closest to today)
        const newest = processedResults[0];
        console.log('üéØ Newest drawing found:', {
            date: newest.date,
            white: newest.white,
            red: newest.red,
            arrayIndex: newest.index
        });
        
        // Also show the closest to today for comparison
        if (closestToToday) {
            console.log('üìç Closest to today:', {
                date: closestToToday.date,
                white: closestToToday.white,
                red: closestToToday.red,
                arrayIndex: closestToToday.index,
                daysDifference: closestToToday.daysDiff.toFixed(1)
            });
        }
        
        // Take only the most recent 100 for efficiency
        const recentResults = processedResults.slice(0, 100);
        
        return recentResults;
        
    } catch (error) {
        console.error('‚ùå Error fetching NY lottery data:', error);
        throw error;
    }
}

function updateFrequencies(data, results) {
    console.log('üìä Calculating frequency statistics...');
    
    // Initialize frequency counters
    for (let i = 1; i <= 69; i++) {
        data.frequency.white[i.toString()] = 0;
    }
    for (let i = 1; i <= 26; i++) {
        data.frequency.red[i.toString()] = 0;
    }
    
    // Count frequencies from all results
    results.forEach(result => {
        result.white.forEach(num => {
            data.frequency.white[num.toString()]++;
        });
        data.frequency.red[result.red.toString()]++;
    });
    
    // Show top frequent numbers
    const topWhite = Object.entries(data.frequency.white)
        .map(([num, freq]) => ({ num: parseInt(num), freq }))
        .sort((a, b) => b.freq - a.freq)
        .slice(0, 5);
    
    const topRed = Object.entries(data.frequency.red)
        .map(([num, freq]) => ({ num: parseInt(num), freq }))
        .sort((a, b) => b.freq - a.freq)
        .slice(0, 3);
    
    console.log('üî• Most frequent white balls:', topWhite.map(x => `${x.num}(${x.freq})`).join(', '));
    console.log('üî¥ Most frequent red balls:', topRed.map(x => `${x.num}(${x.freq})`).join(', '));
}

async function updateLotteryDataFile() {
    try {
        console.log('üé∞ Starting NY.gov lottery data update...');
        
        // Read existing data or create new structure
        let data;
        try {
            const fileContent = fs.readFileSync('lottery-data.json', 'utf8');
            data = JSON.parse(fileContent);
            console.log(`üìÅ Loaded existing data with ${data.results?.length || 0} results`);
        } catch (error) {
            console.log('üìÅ Creating new lottery data file...');
            data = {
                last_updated: new Date().toISOString(),
                results: [],
                frequency: {
                    white: {},
                    red: {}
                },
                source: "NY.gov Official API"
            };
        }
        
        // Fetch latest results from NY.gov
        const newResults = await fetchNYLotteryData();
        
        // Check if we need to add new results
        const existingDates = new Set(data.results.map(r => r.date));
        const newEntries = newResults.filter(result => !existingDates.has(result.date));
        
        if (newEntries.length === 0) {
            console.log('‚ÑπÔ∏è  No new drawings found. Data is up to date.');
            return;
        }
        
        console.log(`‚ûï Adding ${newEntries.length} new drawings`);
        
        // Add new results to beginning (most recent first)
        data.results = [...newEntries, ...data.results];
        
        // Keep only last 200 results
        if (data.results.length > 200) {
            data.results = data.results.slice(0, 200);
            console.log('üóÇÔ∏è  Trimmed to last 200 results');
        }
        
        // Recalculate frequencies
        updateFrequencies(data, data.results);
        
        // Update metadata
        data.last_updated = new Date().toISOString();
        data.source = "NY.gov Official API";
        
        // Write updated data back to file
        fs.writeFileSync('lottery-data.json', JSON.stringify(data, null, 2));
        
        console.log('‚úÖ Successfully updated lottery-data.json');
        console.log(`üìä Total results: ${data.results.length}`);
        console.log(`üìÖ Latest drawing: ${data.results[0].date}`);
        console.log(`üïê Last updated: ${data.last_updated}`);
        
    } catch (error) {
        console.error('üí• Error updating lottery data:', error);
        process.exit(1);
    }
}

// For Node.js environments (GitHub Actions)
if (typeof require !== 'undefined' && require.main === module) {
    // Add fetch polyfill for Node.js
    if (typeof fetch === 'undefined') {
        global.fetch = require('node-fetch');
    }
    
    updateLotteryDataFile();
}

// For browser environments (if needed)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        fetchNYLotteryData,
        updateLotteryDataFile
    };
}
