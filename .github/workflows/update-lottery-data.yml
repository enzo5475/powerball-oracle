const fs = require('fs');

/**
 * Fetches latest Powerball data from NY.gov official API
 * API URL: https://data.ny.gov/api/views/d6yy-54nr/rows.json
 * Data is sorted from newest to oldest (today back to 2010)
 */

async function fetchNYLotteryData() {
    try {
        console.log('🎰 Fetching Powerball data from NY.gov API...');
        
        const response = await fetch('https://data.ny.gov/api/views/d6yy-54nr/rows.json');
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const apiData = await response.json();
        console.log(`📊 Received ${apiData.data.length} total records from NY.gov`);
        
        // Parse the data structure
        // apiData.meta.view.columns contains column definitions
        // apiData.data contains the actual data rows
        
        // Find column indices (NY.gov API structure)
        const columns = apiData.meta.view.columns;
        const columnMap = {};
        
        columns.forEach((col, index) => {
            columnMap[col.name] = index;
        });
        
        console.log('📋 Available columns:', Object.keys(columnMap));
        console.log(`📊 Total records in data array: ${apiData.data.length}`);
        
        // Get today's date for comparison
        const today = new Date();
        today.setHours(0, 0, 0, 0); // Set to start of day for accurate comparison
        console.log(`📅 Today's date: ${today.toISOString().split('T')[0]}`);
        
        // Method 1: Find the highest index (last element in array)
        const highestIndex = apiData.data.length - 1;
        console.log(`🔢 Highest index in array: ${highestIndex}`);
        
        // Method 2: Try to get the entry BEYOND the highest index (highest + 1)
        const beyondHighestIndex = highestIndex + 1;
        console.log(`🔢 Trying index beyond highest: ${beyondHighestIndex}`);
        
        // Check if beyond-highest index exists
        if (apiData.data[beyondHighestIndex]) {
            console.log(`✅ Found entry at index ${beyondHighestIndex}:`, {
                date: apiData.data[beyondHighestIndex][columnMap['Draw Date']] || apiData.data[beyondHighestIndex][1],
                numbers: apiData.data[beyondHighestIndex][columnMap['Winning Numbers']] || apiData.data[beyondHighestIndex][2]
            });
        } else {
            console.log(`❌ No entry found at index ${beyondHighestIndex}, using highest available`);
        }
        
        // Check entries near the end of the array
        console.log('🔍 Checking last 5 entries:');
        for (let i = Math.max(0, highestIndex - 4); i <= highestIndex; i++) {
            const row = apiData.data[i];
            if (row) {
                const date = row[columnMap['Draw Date']] || row[1];
                const numbers = row[columnMap['Winning Numbers']] || row[2];
                console.log(`Index ${i}: Date=${date}, Numbers=${numbers}`);
            }
        }
        
        // Process ALL data to find both the highest index entry AND the closest to today
        const processedResults = [];
        let highestIndexEntry = null;
        let closestToTodayEntry = null;
        let smallestDateDiff = Infinity;
        
        apiData.data.forEach((row, index) => {
            try {
                const drawDate = row[columnMap['Draw Date']] || row[1];
                const winningNumbers = row[columnMap['Winning Numbers']] || row[2];
                const multiplier = row[columnMap['Multiplier']] || row[3];
                
                if (!drawDate || !winningNumbers) {
                    return; // Skip invalid rows
                }
                
                // Parse date - handle format: 2025-05-31T00:00:00
                const date = new Date(drawDate);
                const formattedDate = date.toISOString().split('T')[0]; // YYYY-MM-DD
                
                // Calculate days difference from today
                const daysDiff = Math.abs(today - date) / (1000 * 60 * 60 * 24);
                
                // Parse the winning numbers
                const numbersStr = winningNumbers.toString().trim();
                const allNumbers = numbersStr.match(/\d+/g);
                
                if (!allNumbers || allNumbers.length < 6) {
                    return; // Skip invalid number formats
                }
                
                // Convert to integers
                const numbers = allNumbers.map(n => parseInt(n));
                
                // First 5 are white balls, last is red powerball
                const whiteBalls = numbers.slice(0, 5).sort((a, b) => a - b);
                const powerball = numbers[5];
                
                // Validate number ranges
                const validWhite = whiteBalls.every(n => n >= 1 && n <= 69);
                const validRed = powerball >= 1 && powerball <= 26;
                
                if (!validWhite || !validRed) {
                    return; // Skip invalid ranges
                }
                
                const result = {
                    date: formattedDate,
                    dateObj: date,
                    white: whiteBalls,
                    red: powerball,
                    jackpot: "0",
                    multiplier: multiplier || "1",
                    arrayIndex: index,
                    daysDiff: daysDiff,
                    raw_data: row
                };
                
                processedResults.push(result);
                
                // Track the entry with the highest array index
                if (index === highestIndex) {
                    highestIndexEntry = result;
                }
                
                // Track the entry closest to today's date
                if (daysDiff < smallestDateDiff) {
                    smallestDateDiff = daysDiff;
                    closestToTodayEntry = result;
                }
                
            } catch (error) {
                return; // Skip problematic rows
            }
        });
        
        if (processedResults.length === 0) {
            throw new Error('No valid lottery results found in API response');
        }
        
        // Sort by date - NEWEST FIRST
        processedResults.sort((a, b) => b.dateObj - a.dateObj);
        
        // Remove helper properties
        processedResults.forEach(result => {
            delete result.dateObj;
            delete result.daysDiff;
        });
        
        console.log(`✅ Successfully processed ${processedResults.length} drawings`);
        console.log(`📅 Date range: ${processedResults[processedResults.length-1].date} to ${processedResults[0].date}`);
        
        // Show comparison between different approaches
        console.log('\n🔍 COMPARISON OF APPROACHES:');
        
        const newestByDate = processedResults[0];
        console.log('1️⃣ Newest by date sort:', {
            date: newestByDate.date,
            white: newestByDate.white,
            red: newestByDate.red,
            arrayIndex: newestByDate.arrayIndex
        });
        
        if (highestIndexEntry) {
            console.log('2️⃣ Highest array index entry:', {
                date: highestIndexEntry.date,
                white: highestIndexEntry.white,
                red: highestIndexEntry.red,
                arrayIndex: highestIndexEntry.arrayIndex
            });
        }
        
        if (closestToTodayEntry) {
            console.log('3️⃣ Closest to today:', {
                date: closestToTodayEntry.date,
                white: closestToTodayEntry.white,
                red: closestToTodayEntry.red,
                arrayIndex: closestToTodayEntry.arrayIndex,
                daysDifference: smallestDateDiff.toFixed(1)
            });
        }
        
        // DECISION LOGIC: Use the one closest to today's date
        console.log('\n🎯 USING: Entry closest to today as the latest drawing');
        
        // Put the closest-to-today entry at the front
        if (closestToTodayEntry) {
            // Remove it from its current position
            const filteredResults = processedResults.filter(r => r.arrayIndex !== closestToTodayEntry.arrayIndex);
            // Put it at the front
            processedResults.splice(0, 0, closestToTodayEntry);
        }
        
        // Take only the most recent 100 for efficiency
        const recentResults = processedResults.slice(0, 100);
        
        return recentResults;
        
    } catch (error) {
        console.error('❌ Error fetching NY lottery data:', error);
        throw error;
    }
}

function updateFrequencies(data, results) {
    console.log('📊 Calculating frequency statistics...');
    
    // Initialize frequency counters
    for (let i = 1; i <= 69; i++) {
        data.frequency.white[i.toString()] = 0;
    }
    for (let i = 1; i <= 26; i++) {
        data.frequency.red[i.toString()] = 0;
    }
    
    // Count frequencies from all results
    results.forEach(result => {
        result.white.forEach(num => {
            data.frequency.white[num.toString()]++;
        });
        data.frequency.red[result.red.toString()]++;
    });
    
    // Show top frequent numbers
    const topWhite = Object.entries(data.frequency.white)
        .map(([num, freq]) => ({ num: parseInt(num), freq }))
        .sort((a, b) => b.freq - a.freq)
        .slice(0, 5);
    
    const topRed = Object.entries(data.frequency.red)
        .map(([num, freq]) => ({ num: parseInt(num), freq }))
        .sort((a, b) => b.freq - a.freq)
        .slice(0, 3);
    
    console.log('🔥 Most frequent white balls:', topWhite.map(x => `${x.num}(${x.freq})`).join(', '));
    console.log('🔴 Most frequent red balls:', topRed.map(x => `${x.num}(${x.freq})`).join(', '));
}

async function updateLotteryDataFile() {
    try {
        console.log('🎰 Starting NY.gov lottery data update...');
        
        // Read existing data or create new structure
        let data;
        try {
            const fileContent = fs.readFileSync('lottery-data.json', 'utf8');
            data = JSON.parse(fileContent);
            console.log(`📁 Loaded existing data with ${data.results?.length || 0} results`);
        } catch (error) {
            console.log('📁 Creating new lottery data file...');
            data = {
                last_updated: new Date().toISOString(),
                results: [],
                frequency: {
                    white: {},
                    red: {}
                },
                source: "NY.gov Official API"
            };
        }
        
        // Fetch latest results from NY.gov
        const newResults = await fetchNYLotteryData();
        
        // Check if we need to add new results
        const existingDates = new Set(data.results.map(r => r.date));
        const newEntries = newResults.filter(result => !existingDates.has(result.date));
        
        if (newEntries.length === 0) {
            console.log('ℹ️  No new drawings found. Data is up to date.');
            return;
        }
        
        console.log(`➕ Adding ${newEntries.length} new drawings`);
        
        // Add new results to beginning (most recent first)
        data.results = [...newEntries, ...data.results];
        
        // Keep only last 200 results
        if (data.results.length > 200) {
            data.results = data.results.slice(0, 200);
            console.log('🗂️  Trimmed to last 200 results');
        }
        
        // Recalculate frequencies
        updateFrequencies(data, data.results);
        
        // Update metadata
        data.last_updated = new Date().toISOString();
        data.source = "NY.gov Official API";
        
        // Write updated data back to file
        fs.writeFileSync('lottery-data.json', JSON.stringify(data, null, 2));
        
        console.log('✅ Successfully updated lottery-data.json');
        console.log(`📊 Total results: ${data.results.length}`);
        console.log(`📅 Latest drawing: ${data.results[0].date}`);
        console.log(`🕐 Last updated: ${data.last_updated}`);
        
    } catch (error) {
        console.error('💥 Error updating lottery data:', error);
        process.exit(1);
    }
}

// For Node.js environments (GitHub Actions)
if (typeof require !== 'undefined' && require.main === module) {
    // Add fetch polyfill for Node.js
    if (typeof fetch === 'undefined') {
        global.fetch = require('node-fetch');
    }
    
    updateLotteryDataFile();
}

// For browser environments (if needed)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        fetchNYLotteryData,
        updateLotteryDataFile
    };
}
