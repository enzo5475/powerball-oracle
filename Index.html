<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Powerball Mathematical Oracle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d3a 50%, #3a3a4e 100%);
            color: #7fb069;
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 400px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #7fb069;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(127, 176, 105, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffffff;
            text-shadow: 0 0 10px #7fb069;
            font-size: 1.5em;
        }
        
        .generate-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(45deg, #ff6b35, #f7941d);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 53, 0.4);
        }
        
        .method-group {
            margin-bottom: 15px;
            background: rgba(127, 176, 105, 0.05);
            border-left: 3px solid #7fb069;
            padding: 10px;
            border-radius: 5px;
        }
        
        .method-title {
            color: #7fb069;
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .numbers {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }
        
        .white-ball {
            background: white;
            color: black;
            padding: 8px 10px;
            border-radius: 50%;
            font-weight: bold;
            font-size: 0.9em;
            min-width: 35px;
            text-align: center;
        }
        
        .red-ball {
            background: #dc143c;
            color: white;
            padding: 8px 10px;
            border-radius: 50%;
            font-weight: bold;
            font-size: 0.9em;
            min-width: 35px;
            text-align: center;
        }
        
        .calculation-note {
            font-size: 0.7em;
            color: #888;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            color: #7fb069;
            font-style: italic;
        }
        
        .timestamp {
            text-align: center;
            color: #666;
            font-size: 0.8em;
            margin-top: 15px;
            border-top: 1px solid #333;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”® Mathematical Oracle ðŸ”®</h1>
        <button class="generate-btn" onclick="generateAllMethods()">
            âš¡ Generate Divine Numbers âš¡
        </button>
        
        <div id="results"></div>
        
        <div class="timestamp" id="timestamp"></div>
    </div>

    <script>
        // Mathematical constants and data
        const PI_DIGITS = "31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679";
        const FIBONACCI_SEQUENCE = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765];
        const GOLDEN_RATIO = 1.618033988749;
        
        // Gematria values (simplified Hebrew)
        const GEMATRIA_VALUES = {
            'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10,
            'K': 20, 'L': 30, 'M': 40, 'N': 50, 'O': 60, 'P': 70, 'Q': 80, 'R': 90, 'S': 100,
            'T': 200, 'U': 300, 'V': 400, 'W': 500, 'X': 600, 'Y': 700, 'Z': 800
        };
        
        // Live lottery data
        let LOTTERY_DATA = null;
        
        async function loadLotteryData() {
            try {
                const response = await fetch('lottery-data.json');
                LOTTERY_DATA = await response.json();
                console.log(`Loaded ${LOTTERY_DATA.results.length} lottery results`);
            } catch (error) {
                console.log('Using fallback lottery data');
                // Fallback data if file doesn't exist yet
                LOTTERY_DATA = {
                    results: [],
                    frequency: { white: {}, red: {} }
                };
            }
        }
        
        function getCurrentLunarPhase() {
            const now = new Date();
            const newMoon = new Date('2024-01-11'); // Reference new moon
            const lunarCycle = 29.53059; // days
            const daysSinceNew = (now - newMoon) / (1000 * 60 * 60 * 24);
            const phase = (daysSinceNew % lunarCycle) / lunarCycle;
            return Math.floor(phase * 8); // 8 lunar phases
        }
        
        function calculateLunarNumbers() {
            const phase = getCurrentLunarPhase();
            const now = new Date();
            const lunarDay = now.getDate() + phase;
            
            const whites = [];
            for (let i = 0; i < 5; i++) {
                const num = ((lunarDay * (i + 1) * 7) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining if duplicates occurred
            while (whites.length < 5) {
                const num = Math.floor((phase * whites.length * 13) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = (phase * 3 + now.getDate()) % 26 + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸŒ™ Dynamic - Lunar Phase: ${phase}/8, Lunar influence: ${lunarDay}`
            };
        }
        
        function calculateFibonacciNumbers() {
            const now = new Date();
            const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
            const startIndex = dayOfYear % 15;
            
            const whites = [];
            for (let i = 0; i < 5; i++) {
                const fibIndex = (startIndex + i) % FIBONACCI_SEQUENCE.length;
                const num = (FIBONACCI_SEQUENCE[fibIndex] % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = (FIBONACCI_SEQUENCE[(startIndex + whites.length) % FIBONACCI_SEQUENCE.length] * 2) % 69 + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = (FIBONACCI_SEQUENCE[startIndex % FIBONACCI_SEQUENCE.length] % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸŒ€ Static - Fibonacci sequence starting at index ${startIndex}`
            };
        }
        
        function calculateGoldenRatioNumbers() {
            const now = new Date();
            const timestamp = now.getTime();
            
            const whites = [];
            for (let i = 1; i <= 5; i++) {
                const num = Math.floor((GOLDEN_RATIO * timestamp * i) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = Math.floor((GOLDEN_RATIO * whites.length * timestamp) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = Math.floor((GOLDEN_RATIO * timestamp) % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `âœ¨ Hourly - Golden Ratio Ï† = ${GOLDEN_RATIO.toFixed(6)}`
            };
        }
        
        function calculatePiNumbers() {
            const now = new Date();
            const dayOfYear = Math.floor((now - new Date(now.getFullYear(), 0, 0)) / 86400000);
            const startIndex = dayOfYear % (PI_DIGITS.length - 10);
            
            const whites = [];
            for (let i = 0; i < 10; i++) {
                const digit1 = parseInt(PI_DIGITS[startIndex + i]);
                const digit2 = parseInt(PI_DIGITS[startIndex + i + 1]);
                const num = (digit1 * 10 + digit2) % 69 + 1;
                if (!whites.includes(num) && whites.length < 5) {
                    whites.push(num);
                }
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const digit = parseInt(PI_DIGITS[(startIndex + whites.length) % PI_DIGITS.length]);
                const num = (digit * 7 + whites.length * 3) % 69 + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const redDigit = parseInt(PI_DIGITS[startIndex % PI_DIGITS.length]);
            const red = (redDigit * 3) % 26 + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸ”¢ Daily - Ï€ digits starting at position ${startIndex}`
            };
        }
        
        function calculateGematriaNumbers() {
            const now = new Date();
            const dateString = now.toDateString().toUpperCase().replace(/[^A-Z]/g, '');
            
            let gematriaSum = 0;
            for (let char of dateString) {
                gematriaSum += GEMATRIA_VALUES[char] || 0;
            }
            
            const whites = [];
            for (let i = 1; i <= 5; i++) {
                const num = ((gematriaSum * i) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = ((gematriaSum + whites.length * 11) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = (gematriaSum % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸ“œ Daily - Gematria sum of "${dateString}": ${gematriaSum}`
            };
        }
        
        function calculateKabbalahNumbers() {
            const now = new Date();
            const sephirot = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; // Tree of Life
            const paths = 22; // Hebrew letters/paths
            
            const dayOfMonth = now.getDate();
            const month = now.getMonth() + 1;
            
            const whites = [];
            for (let i = 0; i < 5; i++) {
                const sephira = sephirot[i % 10];
                const num = ((sephira * dayOfMonth * (i + 1)) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = ((paths * month + whites.length * 7) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = ((paths + dayOfMonth) % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸŒ³ Daily - Tree of Life: 10 Sephirot, 22 Paths, Day: ${dayOfMonth}`
            };
        }
        
        function calculateAngelNumbers() {
            const now = new Date();
            const hour = now.getHours();
            const minute = now.getMinutes();
            
            // Angel number patterns: 111, 222, 333, etc.
            const angelPattern = Math.floor(hour / 3) + 1; // 1-8
            const repeatingDigit = angelPattern;
            
            const whites = [];
            for (let i = 1; i <= 5; i++) {
                const num = ((repeatingDigit * 11 * i + minute) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = ((repeatingDigit * whites.length * 7 + hour) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = ((repeatingDigit * 3 + minute) % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸ‘¼ Hourly - Angel pattern: ${repeatingDigit}${repeatingDigit}${repeatingDigit}, Time: ${hour}:${minute}`
            };
        }
        
        function calculateIChing() {
            const now = new Date();
            const year = now.getFullYear();
            const dayOfYear = Math.floor((now - new Date(year, 0, 0)) / 86400000);
            
            // I Ching has 64 hexagrams
            const hexagram = (dayOfYear % 64) + 1;
            
            const whites = [];
            for (let i = 1; i <= 5; i++) {
                const num = ((hexagram * i * 6) % 69) + 1; // 6 lines per hexagram
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = ((hexagram + whites.length * 8) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = (hexagram % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `â˜¯ Daily - I Ching Hexagram: ${hexagram}/64, Day: ${dayOfYear}`
            };
        }
        
        function calculateFrequencyAnalysis() {
            if (!LOTTERY_DATA || !LOTTERY_DATA.frequency) {
                return {
                    whites: [6, 8, 20, 26, 32].sort((a, b) => a - b),
                    red: 13,
                    note: `ðŸ“Š Static - Using fallback frequency data`
                };
            }
            
            // Get most frequent white numbers
            const whiteFreq = Object.entries(LOTTERY_DATA.frequency.white)
                .map(([num, freq]) => ({ num: parseInt(num), freq: parseInt(freq) }))
                .sort((a, b) => b.freq - a.freq);
            
            // Get most frequent red numbers
            const redFreq = Object.entries(LOTTERY_DATA.frequency.red)
                .map(([num, freq]) => ({ num: parseInt(num), freq: parseInt(freq) }))
                .sort((a, b) => b.freq - a.freq);
            
            const now = new Date();
            const useHot = now.getDate() % 2 === 0;
            
            let whites, red;
            
            if (useHot) {
                // Use hot numbers (most frequent)
                whites = whiteFreq.slice(0, 5).map(item => item.num);
                red = redFreq[0]?.num || 1;
            } else {
                // Use cold numbers (least frequent)
                whites = whiteFreq.slice(-5).map(item => item.num);
                red = redFreq[redFreq.length - 1]?.num || 26;
            }
            
            const totalDrawings = LOTTERY_DATA.results.length;
            const lastUpdate = LOTTERY_DATA.last_updated ? 
                new Date(LOTTERY_DATA.last_updated).toLocaleDateString() : 'Unknown';
            
            return {
                whites: whites.sort((a, b) => a - b),
                red: red,
                note: `ðŸ“Š Dynamic - ${useHot ? 'Hot' : 'Cold'} numbers from ${totalDrawings} drawings (Updated: ${lastUpdate})`
            };
        }
        
        function calculateSacredGeometry() {
            const now = new Date();
            
            // Sacred ratios and constants
            const vesicaPiscis = 1.732; // âˆš3
            const pentagram = 1.618; // Golden ratio in pentagon
            const platonic = 5; // Number of Platonic solids
            
            const dayOfMonth = now.getDate();
            
            const whites = [];
            const ratios = [vesicaPiscis, pentagram, Math.PI, Math.E, Math.sqrt(2)];
            
            for (let i = 0; i < 5; i++) {
                const num = Math.floor((ratios[i] * dayOfMonth * (i + 1)) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            // Fill remaining
            while (whites.length < 5) {
                const num = Math.floor((platonic * whites.length * dayOfMonth) % 69) + 1;
                if (!whites.includes(num)) whites.push(num);
            }
            
            const red = Math.floor((pentagram * dayOfMonth) % 26) + 1;
            
            return {
                whites: whites.slice(0, 5).sort((a, b) => a - b),
                red: red,
                note: `ðŸ”º Daily - Sacred geometry: âˆš3, Ï†, Ï€, e, âˆš2 on day ${dayOfMonth}`
            };
        }
        
        function generateAllMethods() {
            const resultsDiv = document.getElementById('results');
            const timestampDiv = document.getElementById('timestamp');
            
            resultsDiv.innerHTML = '<div class="loading">ðŸ”® Calculating divine mathematics... ðŸ”®</div>';
            
            setTimeout(() => {
                const methods = [
                    { name: 'ðŸŒ™ Lunar Calculations', func: calculateLunarNumbers },
                    { name: 'ðŸŒ€ Fibonacci Sequence', func: calculateFibonacciNumbers },
                    { name: 'âœ¨ Golden Ratio', func: calculateGoldenRatioNumbers },
                    { name: 'ðŸ”¢ Pi Sequence', func: calculatePiNumbers },
                    { name: 'ðŸ“œ Gematria', func: calculateGematriaNumbers },
                    { name: 'ðŸŒ³ Kabbalah Tree', func: calculateKabbalahNumbers },
                    { name: 'ðŸ‘¼ Angel Numbers', func: calculateAngelNumbers },
                    { name: 'â˜¯ I Ching', func: calculateIChing },
                    { name: 'ðŸ“Š Frequency Analysis', func: calculateFrequencyAnalysis },
                    { name: 'ðŸ”º Sacred Geometry', func: calculateSacredGeometry }
                ];
                
                let html = '';
                
                methods.forEach(method => {
                    const result = method.func();
                    html += `
                        <div class="method-group">
                            <div class="method-title">${method.name}</div>
                            <div class="numbers">
                                ${result.whites.map(num => `<span class="white-ball">${num}</span>`).join('')}
                                <span class="red-ball">${result.red}</span>
                            </div>
                            <div class="calculation-note">${result.note}</div>
                        </div>
                    `;
                });
                
                resultsDiv.innerHTML = html;
                
                const now = new Date();
                timestampDiv.innerHTML = `Generated: ${now.toLocaleString()}<br>Next lunar phase in ${29.53 - (getCurrentLunarPhase() * 3.69)} days`;
            }, 1500);
        }
        
        // Load lottery data and generate initial numbers on load
        window.onload = async function() {
            await loadLotteryData();
            setTimeout(generateAllMethods, 1000);
        };
    </script>
</body>
</html>
